#include "DWrapperWriter.h"

#include <ctime>
#include <format>
#include <string>

#include "../cppscanner/Utils.h"

using namespace polyglot;

void DWrapperWriter::write(const AST &ast, std::ostream &out) const
{
    auto t = std::time(nullptr);
    std::string timeStr = std::asctime(std::localtime(&t));
    out << std::format(
        R"(// *** WARNING: autogenerated file, do not modify. Changes will be overwritten. ***
// Generated by Polyglot version {} at {}.
// This file contains symbols that have been exported from {} into D.

module {};

@nogc:

)",
        Utils::POLYGLOT_VERSION,
        timeStr.substr(0, timeStr.size() - 1), // remove the '\n'
        "C++", // TODO: make this dynamic
        ast.moduleName);

    for (const auto &node : ast.nodes)
    {
        if (node->nodeType() == ASTNodeType::Function)
        {
            auto function = dynamic_cast<FunctionNode *>(node);
            if (function == nullptr)
                throw std::runtime_error("Node claimed to be FunctionNode, but cast failed");

            if (ast.language == Language::Cpp)
                out << "extern(C++) ";
            else
                out << std::format(R"(pragma(mangle, "{}") )", function->mangledName);
            out << getTypeString(function->returnType) << ' ' << function->functionName << '(';
            std::string params;
            for (const auto &param : function->parameters)
            {
                params += getTypeString(param.type) + ' ' + param.name;
                if (param.defaultValueString.has_value())
//                    params += " = " + getValueString(param.defaultValue.value());
                    params += " = " + param.defaultValueString.value();
                params += ", ";
            }
            out << params.substr(0, params.size() - 2) + ");";
            // TODO: am I missing any qualifiers that could come after the parenthesis?
        }
        else if (node->nodeType() == ASTNodeType::Enum)
        {
            auto e = dynamic_cast<EnumNode *>(node);
            if (e == nullptr)
                throw std::runtime_error("Node claimed to be EnumNode, but cast failed");

            out << "enum " << e->enumName << "\n{\n";
            for (const auto &enumerator : e->enumerators)
            {
                out << '\t' << enumerator.name;
                if (enumerator.valueString.has_value())
//                    out << " = " + getValueString(enumerator.value.value());
                    out << " = " << enumerator.valueString.value();
                out << ",\n";
            }
            out << "}";
        }

        out << "\n";
    }

    out.flush();
}

std::string DWrapperWriter::getTypeString(const QualifiedType &type) const
{
    std::string typeString;
    if (type.isConst)
        typeString += "const ";
    if (type.isReference)
        typeString += "ref ";

    switch (type.baseType)
    {
    case Type::Bool:
        typeString += "bool";
        break;
    case Type::Void:
        typeString += "void";
        break;
    case Type::Char:
        typeString += "char";
        break;
    case Type::Char16:
        typeString += "wchar";
        break;
    case Type::Char32:
        typeString += "dchar";
        break;
    case Type::Int8:
        typeString += "byte";
        break;
    case Type::Int16:
        typeString += "short";
        break;
    case Type::Int32:
        typeString += "int";
        break;
    case Type::Int64:
        typeString += "long";
        break;
    case Type::Int128:
        typeString += "cent";
        break;
    case Type::Uint8:
        typeString += "ubyte";
        break;
    case Type::Uint16:
        typeString += "ushort";
        break;
    case Type::Uint32:
        typeString += "uint";
        break;
    case Type::Uint64:
        typeString += "ulong";
        break;
    case Type::Uint128:
        typeString += "ucent";
        break;
    case Type::Float32:
        typeString += "float";
        break;
    case Type::Float64:
        typeString += "double";
        break;
    case Type::Float128:
        typeString += "real";
        break;
    case Type::Enum:
    case Type::Class:
        if (type.nameString.has_value())
            typeString += type.nameString.value();
        else
            throw std::runtime_error("Enum or class name was not provided to DWrapperWriter");
        break;
    case Type::CppStdString:
        typeString += "basic_string";
        break;
    case Type::Undefined:
        throw std::runtime_error("Undefined type in DWrapperWriter::getTypeString()");
        break;
    }

    if (type.isPointer)
        typeString += " *";

    return typeString;
}

std::string DWrapperWriter::getValueString(const Value &value) const
{
    switch (value.type)
    {
    case Type::Bool:
        return std::to_string(std::get<bool>(value.value));
        break;
    case Type::Char:
        return std::to_string(std::get<char>(value.value));
        break;
    case Type::Char16:
        return std::to_string(std::get<char16_t>(value.value));
        break;
    case Type::Char32:
        return std::to_string(std::get<char32_t>(value.value));
        break;
    case Type::Int8:
    case Type::Int16:
    case Type::Int32:
    case Type::Int64:
        return std::to_string(std::get<int64_t>(value.value));
        break;
    case Type::Uint8:
    case Type::Uint16:
    case Type::Uint32:
    case Type::Uint64:
        return std::to_string(std::get<uint64_t>(value.value));
        break;
    case Type::Float32:
    case Type::Float64:
        return std::to_string(std::get<double>(value.value));
        break;
    case Type::Enum:
    case Type::Class:
        throw std::runtime_error("Enum or class expressions are not yet supported here");
        break;
    case Type::CppStdString:
        return std::get<std::string>(value.value);
        break;
    case Type::Int128:
    case Type::Uint128:
    case Type::Float128:
    case Type::Void:
    case Type::Undefined:
    default:
        throw std::runtime_error("Bad or unsupported type in DWrapperWriter::getValueString()");
        break;
    }
}
