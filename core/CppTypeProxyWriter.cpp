// SPDX-FileCopyrightText: 2023 Klar√§lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>
//
// SPDX-License-Identifier: GPL-3.0

#include "CppTypeProxyWriter.h"

#include <algorithm>
#include <ctime>
#include <format>
#include <iostream>
#include <string>

#include "CppWrapperWriter.h"
#include "Utils.h"

using namespace polyglot;

void CppTypeProxyWriter::generateNeededProxies(polyglot::AST &ast, std::ostream &out)
{
    CppWrapperWriter writer;

    std::stringstream buffer;
    for (auto &node : ast.nodes)
    {
        if (node->nodeType() == ASTNodeType::Function)
        {
            auto function = dynamic_cast<FunctionNode *>(node);
            if (function == nullptr)
                throw std::runtime_error("Node claimed to be FunctionNode, but cast failed");
            if (function->typeProxy.isValid)
                continue;

            auto returnsStdString = function->returnType.baseType == Type::CppStdString;
            auto hasStdStringParam =
                std::find_if(function->parameters.cbegin(), function->parameters.cend(), [](const auto &param) {
                    return param.type.baseType == Type::CppStdString;
                }) != function->parameters.cend();
            if (returnsStdString || hasStdStringParam)
            {
                function->typeProxy.isValid = true;
                function->typeProxy.isReturnProxied = returnsStdString;
                function->typeProxy.proxy = new FunctionNode{*function};
                // TODO: try to mangle this as a regular C++ function instead of just using extern "C" so overrides can work
                function->typeProxy.proxy->functionName = function->functionName + "_polyglot_typeproxy";
                function->typeProxy.proxy->mangledName = function->typeProxy.proxy->functionName;

                buffer << "extern \"C\" ";
                QualifiedType oldReturnType = function->returnType;
                if (returnsStdString)
                {
                    function->typeProxy.proxy->returnType = QualifiedType{Type::Char};
                    function->typeProxy.proxy->returnType.isConst = true;
                    function->typeProxy.proxy->returnType.isPointer = true;
                    buffer << "const char *";
                }
                else
                    buffer << writer.getTypeString(function->returnType) << ' ';

                buffer << function->typeProxy.proxy->mangledName << '(';

                std::string params;
                for (auto &param : function->typeProxy.proxy->parameters)
                {
                    if (param.type.baseType == Type::CppStdString)
                    {
                        function->typeProxy.proxiedParameters.push_back(param.name);
                        params += "const char *";
                        param.type = QualifiedType{Type::Char};
                        param.type.isConst = true;
                        param.type.isPointer = true;
                    }
                    else
                        params += writer.getTypeString(param.type) + ' ';
                    params += param.name + ", ";
                }
                buffer << params.substr(0, params.size() - 2);

                buffer << ")\n{\n\t";
                if (function->returnType != QualifiedType{Type::Void})
                    buffer << "return ";
                if (returnsStdString)
                    buffer << "strdup(";
                buffer << function->functionName << '(';

                params.clear();
                for (auto &param : function->parameters)
                    params += param.name + ", ";
                buffer << params.substr(0, params.size() - 2);

                buffer << ')';
                if (returnsStdString)
                    buffer << ".c_str())";
                buffer << ";\n}\n";
            }
        }
    }

    const auto content = buffer.str();

    // If we don't have anything to write to the output, let's not even bother writing a file.
    if (content.size() <= 0)
        return;

    static int s_onlyWriteHeaderOnce = 0;
    if (s_onlyWriteHeaderOnce == 0)
    {
        auto t = std::time(nullptr);
        std::string timeStr = std::asctime(std::localtime(&t));
        out << std::format(
R"(// *** WARNING: autogenerated file, do not modify. Changes will be overwritten. ***
// Generated by Polyglot version {} at {}.
// This file contains type proxies for {}.

#include <cstring>

#include "../../{}.h"
)",
            Utils::POLYGLOT_VERSION,
            timeStr.substr(0, timeStr.size() - 1), // remove the '\n'
            Utils::getLanguageName(ast), // TODO: use the list of languages that this proxies to
            ast.moduleName);
    }
    ++s_onlyWriteHeaderOnce;
    out << "\n";

    out << content;
}
